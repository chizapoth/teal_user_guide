---
title: "Shiny reactivity"
description: |
  Learn about reactivity
author: "Chi Zhang"
date: "2025-07-14"
categories: [Shiny]
sidebar: false
code-block-bg: true
code-block-border-left: true
highlight-style: tango
format: 
  html:
    toc: true
    toc-depth: 2
    code-fold: false
    code-tools: false
---


Key idea: specify a graph of dependencies, so that when an input changes, all related output are updated automatically.

Usual way in R: procedural. You tell what to do and when. **Imperative programming**

```{r}
#| eval: false
n <- 1
result <- 1 + n
n <- 2
result <- 1 + n
```

Reactive programming: define how to do something; when the right condition meets. **Declarative programming**

```{r}
#| eval: false
result <- reactive({
  1 + input$n
})
```



### Server function 

This is how a skeleton of shiny app looks like:

```{r}
#| eval: false

library(shiny)

ui <- fluidPage(
  # front end interface
)

server <- function(input, output, session) {
  # back end logic
}

shinyApp(ui, server)
```


In the UI part, every user gets the same UI. Not every user gets the same server: user A moves a slider doesn't affect user B. Each session has a unique state, isolating the variables created inside the function. Almost all the reactive programming are inside the server function. 

## Reactivity

```{r}
#| eval: false
ui <- fluidPage(
  textInput("name", "What's your name?"),
  textOutput("greeting")
)

server <- function(input, output, session) {
  output$greeting <- renderText({
    paste0("Hello ", input$name, "!")
  })
}
```

[Run the app](https://hadley.shinyapps.io/ms-connection/)

Every time the `input$name` changes, the output also changes. The **reactivity** simply means that every time a user updates the browser input, the developer does not need to re-run the program. The output is automatically updated by itself. 

*My understanding: the developer only needs to develop the reactive code, then leaves everything to the user. The program reacts to the input*


### Order of execution 

 **Reactive graph**: describes how inputs and outputs are connected.


### Reactive context

Reactive values can only be used inside reactive contexts. Access reactive values outside reactive context will lead to an error. E.g. 

```{r}
#| eval: false

server <- function(input, output){
  print(input$num)
}
# this results in an error, as 'print' is not a reactive context
```

- Any `render*()` is a reactive context
- Use `observe({...})` access reactive variable: it is a reactive context


```{r}
#| eval: false

# this is the correct way to print
server <- function(input, output){
  observe({ 
    print(input$num) # put in the reactive context
  })
  
}
```


### Reactive expressions / variables

Can create a reactive variable using `reactive({})`, which is a **reactive context**.

The order of these two lines below doesn't matter.

```{r}
#| eval: false
server <- function(input, output, session) {
  
  # define a reactive expression here
  string <- reactive(paste0("Hello ", input$name, "!"))
  # can not simply do the line below:
  # paste0("Hello ", input$name, "!")
  
  # call it 
  output$greeting <- renderText(string())
}
```



Access custom reactive variables **like a function**: need the `()`. For example, call `string()` rather than `string`.


```{r}
#| eval: false

server <- function(input, output){
  # create a reactive variable
  x <- reactive({
    input$num + 1
  })  

  observe({
    print(input$num)
    print(x()) # with ()
  })
}

```


### Observe, observeEvent

`shiny::observe` creates **observer**. It updates input's value. Does not have a return value. It gets executed when the reactive values (e.g. `input$value`) it depends on changes.

Common use: `updateSelectInput, updateSliderInput, updateTextInput` to change the input value.

```{r}
#| eval: false

# example from custom module
shiny::observe({
  shiny::updateSelectInput( 
    session,
    "dataset",
    choices = names(data())
  )
})
```

This observe block runs every time input data changes.

`shiny::observeEvent` is a special case of `observe`. It only focuses on one specific change. That is why it has an additional argument, `eventExpr`, which specifies the event to listen to.

```{r}
#| eval: false

# specify what to watch
observeEvent(input$dataset, { 
  req(input$dataset) 
  numeric_vars <- names(data()[[input$dataset]])[sapply(data()[[input$dataset]], is.numeric)]
  shiny::updateSelectInput( # <3>
    session,  
    "variable", 
    choices = numeric_vars)
})
```


## NS and ns

Namespace. `NS` is the **function**, `ns` is the object created by `NS(id)`.

* `NS` takes one argument: `id`. It returns a function (a namespacing function).
* `ns <- NS(id)` is the standard first line of a UI module function.
* `ns` function remembers the ID you assigned.

```{r}
#| eval: true

ns <- shiny::NS(namespace = '1')
ns('my_button') # returns "1-my_button"
```


The purpose of having NS and namespace is to avoid ID collisions when you use the same module multiple times in a single app.

```{r}
#| eval: false

ui_module_ui <- function(id) {
  # 1. Create the namespacing function `ns`
  ns <- shiny::NS(id) 

  # 2. Use `ns` to wrap every ID
  tagList(
    actionButton(ns("my_button"), "Click me"),
    plotOutput(ns("my_plot"))
  )
}
```


* `ui_module_ui("1")` will return `1-my_button`, `1-my_plot`
* `ui_module_ui('2')` will return `2-my_button`, `2-my_plot`





